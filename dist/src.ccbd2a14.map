{"version":3,"sources":["../node_modules/process/browser.js","../node_modules/page/page.js","../node_modules/lit-html/lib/directive.js","../node_modules/lit-html/lib/dom.js","../node_modules/lit-html/lib/part.js","../node_modules/lit-html/lib/template.js","../node_modules/lit-html/lib/template-instance.js","../node_modules/lit-html/lib/template-result.js","../node_modules/lit-html/lib/parts.js","../node_modules/lit-html/lib/default-template-processor.js","../node_modules/lit-html/lib/template-factory.js","../node_modules/lit-html/lib/render.js","../node_modules/lit-html/lit-html.js","../src/narratives/data.js","../src/pages/index.js","../src/routes.js","../src/index.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","browser","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","directives","WeakMap","directive","f","set","isDirective","o","has","isCEPolyfill","window","customElements","undefined","polyfillWrapFlushCallback","reparentNodes","container","start","end","before","node","n","nextSibling","insertBefore","removeNodes","startNode","endNode","removeChild","noChange","String","Math","random","slice","nodeMarker","markerRegex","RegExp","rewritesStyleAttribute","el","document","createElement","setAttribute","getAttribute","Template","constructor","result","element","parts","index","partIndex","nodesToRemove","_prepareTemplate","template","content","walker","createTreeWalker","previousNode","currentNode","nextNode","nodeType","hasAttributes","attributes","count","value","indexOf","stringForPart","strings","lastAttributeNameRegex","exec","attributeLookupName","test","toLowerCase","attributeValue","split","type","removeAttribute","tagName","nodeValue","parent","parentNode","lastIndex","createMarker","createTextNode","previousSibling","Node","TEXT_NODE","isTemplatePartActive","part","createComment","TemplateInstance","processor","getTemplate","_parts","_getTemplate","update","values","setValue","commit","_clone","fragment","cloneNode","importNode","nodeIndex","_prepareInstance","handleTextExpression","insertAfterNode","handleAttributeExpressions","nodeName","TemplateResult","getHTML","l","html","isTextBinding","s","close","lastIndexOf","replace","match","p1","p2","p3","getTemplateElement","innerHTML","SVGTemplateResult","svgElement","firstChild","isPrimitive","AttributeCommitter","dirty","_createPart","AttributePart","_getValue","text","v","isArray","Symbol","iterator","t","comitter","committer","NodePart","templateFactory","_pendingValue","ref","appendIntoPart","_insert","insertAfterPart","_commitText","_commitTemplateResult","_commitNode","_commitIterable","then","_commitPromise","clear","textContent","instance","isConnected","adoptNode","upgrade","itemParts","itemPart","item","BooleanAttributePart","PropertyCommitter","single","PropertyPart","EventPart","eventName","removeEventListener","addEventListener","handleEvent","event","DefaultTemplateProcessor","prefix","defaultTemplateProcessor","templateCache","templateCaches","get","Map","render","templateInstances","defaultTemplateFactory","appendChild","svg","fetchAll","Promise","resolve","id","prompt","choices","choiceText","_","props","narrative","choice","getChoices","store","data","filter","some","map","ctx","routeId","parseInt","params","find","getElementById","console","log","page","redirect","routes"],"mappings":"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CA3C,QAAQoD,mBAAR,GAA8BT,IAA9B;;AAEA3C,QAAQqD,SAAR,GAAoB,UAAUC,IAAV,EAAgB;AAAE,WAAO,EAAP;AAAW,CAAjD;;AAEAtD,QAAQuD,OAAR,GAAkB,UAAUD,IAAV,EAAgB;AAC9B,UAAM,IAAIhD,KAAJ,CAAU,kCAAV,CAAN;AACH,CAFD;;AAIAN,QAAQwD,GAAR,GAAc,YAAY;AAAE,WAAO,GAAP;AAAY,CAAxC;AACAxD,QAAQyD,KAAR,GAAgB,UAAUC,GAAV,EAAe;AAC3B,UAAM,IAAIpD,KAAJ,CAAU,gCAAV,CAAN;AACH,CAFD;AAGAN,QAAQ2D,KAAR,GAAgB,YAAW;AAAE,WAAO,CAAP;AAAW,CAAxC;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","file":"src.ccbd2a14.map","sourceRoot":"../static","sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.page = factory());\n}(this, (function () { 'use strict';\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var suffix = res[6];\n    var asterisk = res[7];\n\n    var repeat = suffix === '+' || suffix === '*';\n    var optional = suffix === '?' || suffix === '*';\n    var delimiter = prefix || '/';\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$');\n    }\n  }\n\n  return function (obj) {\n    var path = '';\n    var data = obj || {};\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path);\n  var re = tokensToRegExp(tokens, options);\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i]);\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n  var lastToken = tokens[tokens.length - 1];\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken);\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = token.pattern;\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || [];\n\n  if (!isarray(keys)) {\n    options = keys;\n    keys = [];\n  } else if (!options) {\n    options = {};\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/**\n   * Module dependencies.\n   */\n\n  \n\n  /**\n   * Module exports.\n   */\n\n  var page_js = page;\n  page.default = page;\n  page.Context = Context;\n  page.Route = Route;\n  page.sameOrigin = sameOrigin;\n\n  /**\n   * Short-cuts for global-object checks\n   */\n\n  var hasDocument = ('undefined' !== typeof document);\n  var hasWindow = ('undefined' !== typeof window);\n  var hasHistory = ('undefined' !== typeof history);\n  var hasProcess = typeof process !== 'undefined';\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var isLocation = hasWindow && !!(window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Strict path matching.\n   */\n\n  var strict = false;\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * The window for which this `page` is running\n   */\n  var pageWindow;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path));\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {string}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Get or set strict path matching to `enable`\n   *\n   * @param {boolean} enable\n   * @api public\n   */\n\n  page.strict = function(enable) {\n    if (0 === arguments.length) return strict;\n    strict = enable;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    pageWindow = options.window || (hasWindow && window);\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate && hasWindow) pageWindow.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click && hasDocument) {\n      pageWindow.document.addEventListener(clickEvent, onclick, false);\n    }\n    hashbang = !!options.hashbang;\n    if(hashbang && hasWindow && !hasHistory) {\n      pageWindow.addEventListener('hashchange', onpopstate, false);\n    }\n    if (!dispatch) return;\n\n    var url;\n    if(isLocation) {\n      var loc = pageWindow.location;\n\n      if(hashbang && ~loc.hash.indexOf('#!')) {\n        url = loc.hash.substr(2) + loc.search;\n      } else if (hashbang) {\n        url = loc.search + loc.hash;\n      } else {\n        url = loc.pathname + loc.search + loc.hash;\n      }\n    }\n\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    hasDocument && pageWindow.document.removeEventListener(clickEvent, onclick, false);\n    hasWindow && pageWindow.removeEventListener('popstate', onpopstate, false);\n    hasWindow && pageWindow.removeEventListener('hashchange', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state),\n      prev = prevContext;\n    prevContext = ctx;\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx, prev);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      hasHistory && pageWindow.history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(getBase(), state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state),\n      prev = prevContext;\n    prevContext = ctx;\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx, prev);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx, prev) {\n    var i = 0,\n      j = 0;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = isLocation && getBase() + pageWindow.location.hash.replace('#!', '');\n    } else {\n      current = isLocation && pageWindow.location.pathname + pageWindow.location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    isLocation && (pageWindow.location.href = ctx.canonicalPath);\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    var pageBase = getBase();\n    if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(pageBase, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = (hasDocument && pageWindow.document.title);\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = this.pathname = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    if (hasHistory) {\n        pageWindow.history.pushState(this.state, this.title,\n          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n    }\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    if (hasHistory && pageWindow.location.protocol !== 'file:') {\n        pageWindow.history.replaceState(this.state, this.title,\n          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n    }\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    options.strict = options.strict || strict;\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathToRegexp_1(this.path,\n      this.keys = [],\n      options);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ( ! hasWindow ) {\n      return;\n    }\n    if (hasDocument && document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else if (isLocation) {\n        var loc = pageWindow.location;\n        page.show(loc.pathname + loc.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  /* jshint +W054 */\n  function onclick(e) {\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n    // ensure link\n    // use shadow dom when available if not, fall back to composedPath() for browsers that only have shady\n    var el = e.target;\n    var eventPath = e.path || (e.composedPath ? e.composedPath() : null);\n\n    if(eventPath) {\n      for (var i = 0; i < eventPath.length; i++) {\n        if (!eventPath[i].nodeName) continue;\n        if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;\n        if (!eventPath[i].href) continue;\n\n        el = eventPath[i];\n        break;\n      }\n    }\n    // continue ensure link\n    // el.nodeName for svg links are 'a' instead of 'A'\n    while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName.toUpperCase()) return;\n\n    // check if link is inside an svg\n    // in this case, both href and target are always inside an object\n    var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if(!hashbang && samePath(el) && (el.hash || '#' === link)) return;\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    // svg target is an object and its desired value is in .baseVal property\n    if (svg ? el.target.baseVal : el.target) return;\n\n    // x-origin\n    // note: svg links that are not relative don't call click events (and skip page.js)\n    // consequently, all svg links tested inside page.js are relative and in the same origin\n    if (!svg && !sameOrigin(el.href)) return;\n\n    // rebuild path\n    // There aren't .pathname and .search properties in svg links, so we use href\n    // Also, svg href is an object and its desired value is in .baseVal property\n    var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));\n\n    path = path[0] !== '/' ? '/' + path : path;\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (hasProcess && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n    var pageBase = getBase();\n\n    if (path.indexOf(pageBase) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (pageBase && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || (hasWindow && window.event);\n    return null == e.which ? e.button : e.which;\n  }\n\n  /**\n   * Convert to a URL object\n   */\n  function toURL(href) {\n    if(typeof URL === 'function' && isLocation) {\n      return new URL(href, location.toString());\n    } else if (hasDocument) {\n      var anc = document.createElement('a');\n      anc.href = href;\n      return anc;\n    }\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    if(!href || !isLocation) return false;\n    var url = toURL(href);\n\n    var loc = pageWindow.location;\n    return loc.protocol === url.protocol &&\n      loc.hostname === url.hostname &&\n      loc.port === url.port;\n  }\n\n  function samePath(url) {\n    if(!isLocation) return false;\n    var loc = pageWindow.location;\n    return url.pathname === loc.pathname &&\n      url.search === loc.search;\n  }\n\n  /**\n   * Gets the `base`, which depends on whether we are using History or\n   * hashbang routing.\n   */\n  function getBase() {\n    if(!!base) return base;\n    var loc = hasWindow && pageWindow && pageWindow.location;\n    return (hasWindow && hashbang && loc && loc.protocol === 'file:') ? loc.pathname : base;\n  }\n\n  page.sameOrigin = sameOrigin;\n\nreturn page_js;\n\n})));\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\nexport const directive = (f) => {\n    directives.set(f, true);\n    return f;\n};\nexport const isDirective = (o) => typeof o === 'function' && directives.has(o);\n//# sourceMappingURL=directive.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nexport const isCEPolyfill = window.customElements !== undefined &&\n    window.customElements.polyfillWrapFlushCallback !== undefined;\n/**\n * Reparents nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), into another container (could be the same container), before\n * `beforeNode`. If `beforeNode` is null, it appends the nodes to the\n * container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    let node = start;\n    while (node !== end) {\n        const n = node.nextSibling;\n        container.insertBefore(node, before);\n        node = n;\n    }\n};\n/**\n * Removes nodes, starting from `startNode` (inclusive) to `endNode`\n * (exclusive), from `container`.\n */\nexport const removeNodes = (container, startNode, endNode = null) => {\n    let node = startNode;\n    while (node !== endNode) {\n        const n = node.nextSibling;\n        container.removeChild(node);\n        node = n;\n    }\n};\n//# sourceMappingURL=dom.js.map","/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n//# sourceMappingURL=part.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, not attribute positions,\n * in template.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\nexport const rewritesStyleAttribute = (() => {\n    const el = document.createElement('div');\n    el.setAttribute('style', '{{bad value}}');\n    return el.getAttribute('style') !== '{{bad value}}';\n})();\n/**\n * An updateable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        let index = -1;\n        let partIndex = 0;\n        const nodesToRemove = [];\n        const _prepareTemplate = (template) => {\n            const content = template.content;\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\n                   NodeFilter.SHOW_TEXT */, null, false);\n            // The actual previous node, accounting for removals: if a node is removed\n            // it will never be the previousNode.\n            let previousNode;\n            // Used to set previousNode at the top of the loop.\n            let currentNode;\n            while (walker.nextNode()) {\n                index++;\n                previousNode = currentNode;\n                const node = currentNode = walker.currentNode;\n                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                    if (node.hasAttributes()) {\n                        const attributes = node.attributes;\n                        // Per\n                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                        // attributes are not guaranteed to be returned in document order.\n                        // In particular, Edge/IE can return them out of order, so we cannot\n                        // assume a correspondance between part index and attribute index.\n                        let count = 0;\n                        for (let i = 0; i < attributes.length; i++) {\n                            if (attributes[i].value.indexOf(marker) >= 0) {\n                                count++;\n                            }\n                        }\n                        while (count-- > 0) {\n                            // Get the template literal section leading up to the first\n                            // expression in this attribute\n                            const stringForPart = result.strings[partIndex];\n                            // Find the attribute name\n                            const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                            // Find the corresponding attribute\n                            // If the attribute name contains special characters, lower-case\n                            // it so that on XML nodes with case-sensitive getAttribute() we\n                            // can still find the attribute, which will have been lower-cased\n                            // by the parser.\n                            //\n                            // If the attribute name doesn't contain special character, it's\n                            // important to _not_ lower-case it, in case the name is\n                            // case-sensitive, like with XML attributes like \"viewBox\".\n                            const attributeLookupName = (rewritesStyleAttribute && name === 'style') ?\n                                'style$' :\n                                /^[a-zA-Z-]*$/.test(name) ? name : name.toLowerCase();\n                            const attributeValue = node.getAttribute(attributeLookupName);\n                            const strings = attributeValue.split(markerRegex);\n                            this.parts.push({ type: 'attribute', index, name, strings });\n                            node.removeAttribute(attributeLookupName);\n                            partIndex += strings.length - 1;\n                        }\n                    }\n                    if (node.tagName === 'TEMPLATE') {\n                        _prepareTemplate(node);\n                    }\n                }\n                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                    const nodeValue = node.nodeValue;\n                    if (nodeValue.indexOf(marker) < 0) {\n                        continue;\n                    }\n                    const parent = node.parentNode;\n                    const strings = nodeValue.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        parent.insertBefore((strings[i] === '') ? createMarker() :\n                            document.createTextNode(strings[i]), node);\n                        this.parts.push({ type: 'node', index: index++ });\n                    }\n                    parent.insertBefore(strings[lastIndex] === '' ?\n                        createMarker() :\n                        document.createTextNode(strings[lastIndex]), node);\n                    nodesToRemove.push(node);\n                }\n                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                    if (node.nodeValue === marker) {\n                        const parent = node.parentNode;\n                        // Add a new marker node to be the startNode of the Part if any of\n                        // the following are true:\n                        //  * We don't have a previousSibling\n                        //  * previousSibling is being removed (thus it's not the\n                        //    `previousNode`)\n                        //  * previousSibling is not a Text node\n                        //\n                        // TODO(justinfagnani): We should be able to use the previousNode\n                        // here as the marker node and reduce the number of extra nodes we\n                        // add to a template. See\n                        // https://github.com/PolymerLabs/lit-html/issues/147\n                        const previousSibling = node.previousSibling;\n                        if (previousSibling === null || previousSibling !== previousNode ||\n                            previousSibling.nodeType !== Node.TEXT_NODE) {\n                            parent.insertBefore(createMarker(), node);\n                        }\n                        else {\n                            index--;\n                        }\n                        this.parts.push({ type: 'node', index: index++ });\n                        nodesToRemove.push(node);\n                        // If we don't have a nextSibling add a marker node.\n                        // We don't have to check if the next node is going to be removed,\n                        // because that node will induce a new marker if so.\n                        if (node.nextSibling === null) {\n                            parent.insertBefore(createMarker(), node);\n                        }\n                        else {\n                            index--;\n                        }\n                        currentNode = previousNode;\n                        partIndex++;\n                    }\n                    else {\n                        let i = -1;\n                        while ((i = node.nodeValue.indexOf(marker, i + 1)) !== -1) {\n                            // Comment node has a binding marker inside, make an inactive part\n                            // The binding won't work, but subsequent bindings will\n                            // TODO (justinfagnani): consider whether it's even worth it to\n                            // make bindings in comments work\n                            this.parts.push({ type: 'node', index: -1 });\n                        }\n                    }\n                }\n            }\n        };\n        _prepareTemplate(element);\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#attributes-0\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-character\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = /([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \\x09\\x0a\\x0c\\x0d\"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, processor, getTemplate) {\n        this._parts = [];\n        this.template = template;\n        this.processor = processor;\n        this._getTemplate = getTemplate;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // When using the Custom Elements polyfill, clone the node, rather than\n        // importing it, to keep the fragment in the template's document. This\n        // leaves the fragment inert so custom elements won't upgrade and\n        // potentially modify their contents by creating a polyfilled ShadowRoot\n        // while we traverse the tree.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const parts = this.template.parts;\n        let partIndex = 0;\n        let nodeIndex = 0;\n        const _prepareInstance = (fragment) => {\n            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be\n            // null\n            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n            let node = walker.nextNode();\n            // Loop through all the nodes and parts of a template\n            while (partIndex < parts.length && node !== null) {\n                const part = parts[partIndex];\n                // Consecutive Parts may have the same node index, in the case of\n                // multiple bound attributes on an element. So each iteration we either\n                // increment the nodeIndex, if we aren't on a node with a part, or the\n                // partIndex if we are. By not incrementing the nodeIndex when we find a\n                // part, we allow for the next part to be associated with the current\n                // node if neccessasry.\n                if (!isTemplatePartActive(part)) {\n                    this._parts.push(undefined);\n                    partIndex++;\n                }\n                else if (nodeIndex === part.index) {\n                    if (part.type === 'node') {\n                        const part = this.processor.handleTextExpression(this._getTemplate);\n                        part.insertAfterNode(node);\n                        this._parts.push(part);\n                    }\n                    else {\n                        this._parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings));\n                    }\n                    partIndex++;\n                }\n                else {\n                    nodeIndex++;\n                    if (node.nodeName === 'TEMPLATE') {\n                        _prepareInstance(node.content);\n                    }\n                    node = walker.nextNode();\n                }\n            }\n        };\n        _prepareInstance(fragment);\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { reparentNodes } from './dom.js';\nimport { lastAttributeNameRegex, marker, nodeMarker, rewritesStyleAttribute } from './template.js';\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a <template> element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isTextBinding = true;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            html += s;\n            const close = s.lastIndexOf('>');\n            // We're in a text position if the previous string closed its last tag, an\n            // attribute position if the string opened an unclosed tag, and unchanged\n            // if the string had no brackets at all:\n            //\n            // \"...>...\": text position. open === -1, close > -1\n            // \"...<...\": attribute position. open > -1\n            // \"...\": no change. open === -1, close === -1\n            isTextBinding =\n                (close > -1 || isTextBinding) && s.indexOf('<', close + 1) === -1;\n            if (!isTextBinding && rewritesStyleAttribute) {\n                html = html.replace(lastAttributeNameRegex, (match, p1, p2, p3) => {\n                    return (p2 === 'style') ? `${p1}style$${p3}` : match;\n                });\n            }\n            html += isTextBinding ? nodeMarker : marker;\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTMl in an <svg> tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the <svg> tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isDirective } from './directive.js';\nimport { isCEPolyfill, removeNodes } from './dom.js';\nimport { noChange } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = (value) => (value === null ||\n    !(typeof value === 'object' || typeof value === 'function'));\n/**\n * Sets attribute values for AttributeParts, so that the value is only set once\n * even if there are multiple parts for an attribute.\n */\nexport class AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (v != null &&\n                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n                else {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\nexport class AttributePart {\n    constructor(comitter) {\n        this.value = undefined;\n        this.committer = comitter;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\nexport class NodePart {\n    constructor(templateFactory) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        this.templateFactory = templateFactory;\n    }\n    /**\n     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and\n     * its next sibling must be static, unchanging nodes such as those that appear\n     * in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part._insert(this.startNode = createMarker());\n        part._insert(this.endNode = createMarker());\n    }\n    /**\n     * Appends this part after `ref`\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref._insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        const value = this._pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this._commitText(value);\n            }\n        }\n        else if (value instanceof TemplateResult) {\n            this._commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this._commitNode(value);\n        }\n        else if (Array.isArray(value) || value[Symbol.iterator]) {\n            this._commitIterable(value);\n        }\n        else if (value.then !== undefined) {\n            this._commitPromise(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    _commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this._insert(value);\n        this.value = value;\n    }\n    _commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === Node.TEXT_NODE) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.textContent = value;\n        }\n        else {\n            this._commitNode(document.createTextNode(typeof value === 'string' ? value : String(value)));\n        }\n        this.value = value;\n    }\n    _commitTemplateResult(value) {\n        const template = this.templateFactory(value);\n        let instance;\n        if (this.value && this.value.template === template) {\n            instance = this.value;\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use it's syntax extension, etc. The template factory comes\n            // from the render function so that it can control caching.\n            instance =\n                new TemplateInstance(template, value.processor, this.templateFactory);\n            const fragment = instance._clone();\n            // Since we cloned in the polyfill case, now force an upgrade\n            if (isCEPolyfill && !this.endNode.isConnected) {\n                document.adoptNode(fragment);\n                customElements.upgrade(fragment);\n            }\n            this._commitNode(fragment);\n            this.value = instance;\n        }\n        instance.update(value.values);\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new NodePart(this.templateFactory);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    _commitPromise(value) {\n        this.value = value;\n        value.then((v) => {\n            if (this.value === value) {\n                this.setValue(v);\n                this.commit();\n            }\n        });\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        if (this._pendingValue === noChange) {\n            return;\n        }\n        const value = !!this._pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n        }\n        this.value = value;\n        this._pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n}\nexport class EventPart {\n    constructor(element, eventName) {\n        this.value = undefined;\n        this._pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n    }\n    setValue(value) {\n        this._pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this._pendingValue)) {\n            const directive = this._pendingValue;\n            this._pendingValue = noChange;\n            directive(this);\n        }\n        if (this._pendingValue === noChange) {\n            return;\n        }\n        if ((this._pendingValue == null) !== (this.value == null)) {\n            if (this._pendingValue == null) {\n                this.element.removeEventListener(this.eventName, this);\n            }\n            else {\n                this.element.addEventListener(this.eventName, this);\n            }\n        }\n        this.value = this._pendingValue;\n        this._pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.element, event);\n        }\n        else if (typeof this.value.handleEvent === 'function') {\n            this.value.handleEvent(event);\n        }\n    }\n}\n//# sourceMappingURL=parts.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter } from './parts.js';\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const comitter = new PropertyCommitter(element, name.slice(1), strings);\n            return comitter.parts;\n        }\n        if (prefix === '@') {\n            return [new EventPart(element, name.slice(1))];\n        }\n        if (prefix === '?') {\n            return [new BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const comitter = new AttributeCommitter(element, name, strings);\n        return comitter.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(templateFactory) {\n        return new NodePart(templateFactory);\n    }\n}\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { Template } from './template.js';\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = new Map();\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n        template = new Template(result, result.getTemplateElement());\n        templateCache.set(result.strings, template);\n    }\n    return template;\n}\n// The first argument to JS template tags retain identity across multiple\n// calls to a tag for the same literal, so we can cache work done per literal\n// in a Map.\nexport const templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isCEPolyfill, removeNodes } from './dom.js';\nimport { templateFactory as defaultTemplateFactory } from './template-factory.js';\nimport { TemplateInstance } from './template-instance.js';\nexport const templateInstances = new WeakMap();\n/**\n * Renders a template to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result a TemplateResult created by evaluating a template tag like\n *     `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param templateFactory a function to create a Template or retreive one from\n *     cache.\n */\nexport function render(result, container, templateFactory = defaultTemplateFactory) {\n    const template = templateFactory(result);\n    let instance = templateInstances.get(container);\n    // Repeat render, just call update()\n    if (instance !== undefined && instance.template === template &&\n        instance.processor === result.processor) {\n        instance.update(result.values);\n        return;\n    }\n    // First render, create a new TemplateInstance and append it\n    instance = new TemplateInstance(template, result.processor, templateFactory);\n    templateInstances.set(container, instance);\n    const fragment = instance._clone();\n    removeNodes(container, container.firstChild);\n    // Since we cloned in the polyfill case, now force an upgrade\n    if (isCEPolyfill && !container.isConnected) {\n        document.adoptNode(fragment);\n        customElements.upgrade(fragment);\n    }\n    container.appendChild(fragment);\n    instance.update(result.values);\n}\n//# sourceMappingURL=render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { defaultTemplateProcessor } from './lib/default-template-processor.js';\nimport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport * from './lib/template-result.js';\nexport * from './lib/template.js';\nexport * from './lib/default-template-processor.js';\nexport * from './lib/template-instance.js';\nexport * from './lib/part.js';\nexport * from './lib/parts.js';\nexport * from './lib/dom.js';\nexport * from './lib/directive.js';\nexport * from './lib/render.js';\nexport * from './lib/template-factory.js';\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map","// @flow\n\nimport type { Narrative } from './types'\n\nexport const fetchAll = async (): Promise<Narrative[]> =>\n  Promise.resolve([\n    {\n      id: 0,\n      text: 'This is the data text',\n      prompt: 'What will you do next?',\n      choices: [1, 2]\n    },\n    {\n      id: 1,\n      text: 'some story a',\n      choiceText: 'go with option a'\n    },\n    {\n      id: 2,\n      text: 'some story b',\n      choiceText: 'go with option b'\n    }\n  ])\n","// @flow\nimport type { Narrative, NarrativeId } from '../narratives/types'\n\nimport { render, html } from 'lit-html'\n\nimport { fetchAll } from '../narratives/data'\n\ntype IndexProps = {\n  narrative: Narrative,\n  store: { data: Narrative[] }\n}\n\nconst title = (_: IndexProps) => html`\n<h4 class=\"index__title\">\n  <a href=\"/\" class=\"index__title-link\">\n    Galactic Pigs: A Prelude\n  </a>\n</h4>`\n\nconst text = (props: IndexProps) =>\n  html`<div class=\"index__text\">${props.narrative.text}</div>`\n\nconst prompt = (props: IndexProps) =>\n  html`<div class=\"index__prompt\">${props.narrative.prompt}</div>`\n\nconst choice = (props: IndexProps) => html`\n  <div class=\"index__choice\">\n    <a href=\"${props.narrative.id}\" class=\"index__choice-button\">${\n  props.narrative.choiceText\n}</a>\n  </div>\n`\nconst getChoices = (props: IndexProps) =>\n  props.store.data.filter(\n    n =>\n      Array.isArray(props.narrative.choices) &&\n      props.narrative.choices.some((id: NarrativeId) => id === n.id)\n  )\n\nconst choices = (props: IndexProps) => html`\n<div class=\"index__choices\">\n  ${getChoices(props).map(n => choice({ narrative: n, store: props.store }))}\n</div>`\n\nconst index = (props: IndexProps) => html`\n  <div class=\"index\">\n    ${title(props)}\n    <div class=\"index__body\">\n      ${text(props)}\n    </div>\n    <div class=\"index__footer\" aria-hidden=\"true\">\n      ${prompt(props)}\n      ${choices(props)}\n    </div>\n    <div class=\"index__footer index__footer--overlay\">\n      ${prompt(props)}\n      ${choices(props)}\n    </div>\n  </div>\n`\n\ntype RouteContext = {\n  params: {\n    [string]: string\n  }\n}\n\nexport default async (ctx: RouteContext) => {\n  const data = await fetchAll()\n  const store: { data: Narrative[] } = {\n    data\n  }\n  const routeId: number = parseInt(ctx.params.id, 10)\n  const narrative = store.data.find(n => n.id === routeId)\n  if (narrative) {\n    render(index({ narrative, store }), document.getElementById('app'))\n  } else {\n    console.log('lameo')\n  }\n}\n","// @flow\n\nimport page from 'page'\n\nimport index from './pages/index'\n\nexport const map = () => {\n  page('/', _ => page.redirect('/1'))\n  page('/:id', index)\n  page()\n}\n","import * as routes from './routes'\n\nroutes.map()\n"]}